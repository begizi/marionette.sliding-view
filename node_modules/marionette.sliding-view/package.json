{
  "name": "marionette.sliding-view",
  "version": "0.0.1",
  "description": "A sliding Collection View in Marionette.",
  "main": "dist/marionette.sliding-view.js",
  "scripts": {
    "test": "gulp",
    "test-browser": "gulp test-browser",
    "build": "gulp build",
    "coverage": "gulp coverage"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jmeas/marionette.sliding-view.git"
  },
  "keywords": [
    "backbone",
    "marionette",
    "backbone.marionette",
    "slickgrid",
    "slick",
    "grid",
    "sliding",
    "infinite",
    "scroll",
    "view",
    "collection",
    "efficient",
    "render",
    "list"
  ],
  "author": {
    "name": "Jmeas"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/jmeas/marionette.sliding-view/issues"
  },
  "homepage": "https://github.com/jmeas/marionette.sliding-view",
  "dependencies": {
    "underscore": "1.4.4 - 1.7.0",
    "backbone": "1.1.0 - 1.1.2",
    "backbone.marionette": "^2.0.0"
  },
  "devDependencies": {
    "babel": "^4.3.0",
    "babelify": "^5.0.3",
    "browserify": "^8.1.1",
    "chai": "^2.0.0",
    "del": "^1.1.1",
    "esperanto": "^0.6.7",
    "glob": "^4.3.5",
    "gulp": "^3.8.10",
    "gulp-babel": "^4.0.0",
    "gulp-file": "^0.2.0",
    "gulp-filter": "^2.0.0",
    "gulp-istanbul": "^0.6.0",
    "gulp-jscs": "^1.4.0",
    "gulp-jshint": "^1.9.0",
    "gulp-livereload": "^3.4.0",
    "gulp-load-plugins": "^0.8.0",
    "gulp-mocha": "^2.0.0",
    "gulp-notify": "^2.1.0",
    "gulp-plumber": "^0.6.6",
    "gulp-rename": "^1.2.0",
    "gulp-sourcemaps": "^1.3.0",
    "gulp-uglifyjs": "^0.6.0",
    "isparta": "^2.0.0",
    "jquery": "^2.1.3",
    "jsdom": "^3.1.1",
    "jshint-stylish": "^1.0.0",
    "mkdirp": "^0.5.0",
    "mocha": "^2.1.0",
    "run-sequence": "^1.0.2",
    "sinon": "^1.12.2",
    "sinon-chai": "^2.7.0",
    "vinyl-source-stream": "^1.0.0"
  },
  "babelBoilerplateOptions": {
    "entryFileName": "marionette.sliding-view.js",
    "exportVarName": "none",
    "mochaGlobals": [
      "stub",
      "spy",
      "expect",
      "_",
      "$",
      "Bb",
      "Mn"
    ]
  },
  "readme": "# marionette.sliding-view\n[![Travis build status](http://img.shields.io/travis/jmeas/marionette.sliding-view.svg?style=flat)](https://travis-ci.org/jmeas/marionette.sliding-view)\n[![Code Climate](https://codeclimate.com/github/jmeas/marionette.sliding-view/badges/gpa.svg)](https://codeclimate.com/github/jmeas/marionette.sliding-view)\n[![Test Coverage](https://codeclimate.com/github/jmeas/marionette.sliding-view/badges/coverage.svg)](https://codeclimate.com/github/jmeas/marionette.sliding-view)\n[![Dependency Status](https://david-dm.org/jmeas/marionette.sliding-view.svg)](https://david-dm.org/jmeas/marionette.sliding-view)\n[![devDependency Status](https://david-dm.org/jmeas/marionette.sliding-view/dev-status.svg)](https://david-dm.org/jmeas/marionette.sliding-view#info=devDependencies)\n\nA sliding Collection View in Marionette.\n\n### Motivation\n\nSome Collections contain many, many items, and rendering them all at once with a CollectionView\ncan take a very long time. A 'sliding' CollectionView only displays some of the models at once (typically, only those\nvisible), giving you fast load times even as the number of items goes into the tens of thousands.\n\n### Getting Started\n\nThis is a more complex view class. Accordingly, it may take some time to fully understand the API it provides.\nOnce you've got it down, though, you should find that it's a really powerful tool.\n\n#### Concepts\n\nUnderstanding a few core concepts will help you to use the SlidingView.\n\n##### Reference Collection\n\nA SlidingView has two collections: `collection` and `referenceCollection`. The `collection`\nrepresents only the models that are *currently* being displayed. The `referenceCollection` is the\nfull list of models that the SlidingView represents.\n\n##### Update Event\n\nThe SlidingView determines if it needs to change the models that are displayed whenever the \"update event\"\noccurs. By default, the \"update event\" is the scroll event on the SlidingView's element.\n\nAlthough in most cases the update event is typically a scroll event, it could be anything.\n\n##### Lower and Upper Boundaries\n\nThe SlidingView has two internal properties, called the `lowerBound` and `upperBound`. These\nare two properties that can be used to determine which models from the reference collection\nshould be displayed at any given time.\n\nThere are two hooks that are used to set the boundaries, and they are called everytime that\nthe update event occurs.\n\nIn the simplest case, the boundaries will be indices that represent which indices to `slice`\nthe `referenceCollection` at.\n\n### API\n\n##### `constructor( [options] )`\n\nA `CollectionView` typically receives a `collection` as an option. SlidingView is different in that you\n**do not** pass in a `collection`. Instead, pass it in as the option `referenceCollection`. While the\n`referenceCollection` represents the full list of models, the `collection` attribute will be created for\nyou, and will be kept up-to-date with the current models that are displayed in the View.\n\nYou can either pass the `referenceCollection` as an option, or specify it on the prototype.\n\n##### `registerUpdateEvent()`\n\nA hook that lets you register when to call the `onUpdateEvent` method. By default,\nthe SlidingView listens to `scroll` events on its own element. By overriding this,\nyou could make it update its collection when another element (like a parent) is scrolled,\nor any time any event occurs.\n\nWhen overriding this method, use the `onUpdateEvent` method as your callback for the event.\n\n```js\nvar MySlidingView = Mn.SlidingView.extend({\n\n  // Update whenever a model changes\n  registerUpdateEvent: function() {\n    var self = this;\n    this.listenTo(someModel, 'change', function() {\n      self.onUpdateEvent();\n    });\n  }\n});\n```\n\n##### `onUpdateEvent()`\n\nA callback that is executed every time the registered update event happens. The purpose\nof this callback is to throttle the *true* callback to the event, which is\n`throttledUpdateHandler`.\n\nThe default behavior is to throttle the `throttledUpdateHandler` method using the `throttle`\nmethod on the SlidingView.\n\nFor a big performance boost, you are highly encouraged to override this method to use\n`requestAnimationFrame`.\n\n```js\nvar MySlidingView = Mn.SlidingView.extend({\n\n  // Use requestAnimationFrame for a big performance boost!\n  onUpdateEvent: function() {\n    requestAnimationFrame(this.throttledUpdateHandler);\n  }\n});\n```\n\n##### `throttledUpdateHandler()`\n\nThis is the method that contains all of the logic for the intelligent SlidingView updates. It is\nnot recommended that you override this method. You only need to do anything with it when defining\na custom `onUpdateEvent` method.\n\n##### `throttle( fn )`\n\nIf you're not using `requestAnimationFrame` (you should be!), then you can specify how\nto throttle `fn` here. The default implementation is to use `_.throttle` at 60 fps.\n\nNote that if you **are** using `requestAnimationFrame`, then you can ignore this method\nentirely.\n\n##### `pruneCollection(lowerBound, upperBound)`\n\nUse the values of `lowerBound` and `upperBound` to calculate a list of models to be\n`set` on the SlidingView's `collection`. By default, all of the models from\n`referenceCollection` are returned.\n\nIf your upper and lower boundaries reference indices, then you could `slice` your collection\nto return just the models within those indices.\n\n```js\nvar MySlidingView = Mn.SlidingView.extend({\n  pruneCollection: function(lowerBound, upperBound) {\n    return this.referenceCollection.slice(lowerBound, upperBound)\n  }\n});\n```\n\n##### `initialLowerBound`\n\nThe initial lower boundary for the SlidingView. It can be a flat value or a function.\n\n```js\nvar MySlidingView = Mn.SlidingView.extend({\n  initialLowerBound: 3\n});\n```\n\n##### `initialUpperBound`\n\nThe initial upper boundary for the SlidingView. It can be a flat value or a function.\n\n```js\nvar MySlidingView = Mn.SlidingView.extend({\n  initialLowerBound: function() {\n    return 5;\n  }\n});\n```\n\n##### `getLowerBound()`\n\nA function that is called each time the update event occurs. Within this method\nyou should calculate the new value of the `lowerBound` and return it.\n\n##### `getUpperBound( lowerBound )`\n\nSimilar to the above, but for the upper boundary. It is passed the `lowerBound` that\nwas just computed, if you need to use that as a reference.\n",
  "readmeFilename": "README.md",
  "gitHead": "7c646c5f4aee10692fe0349f6d45cdbeeae79c9d",
  "_id": "marionette.sliding-view@0.0.1",
  "_shasum": "b00381dcae4b8df90bc7798d8c0a2273c8b5727a",
  "_from": "marionette.sliding-view@*"
}
