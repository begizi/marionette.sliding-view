{"version":3,"sources":["marionette.sliding-view.js"],"names":[],"mappings":"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","file":"marionette.sliding-view.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('underscore'), require('backbone'), require('backbone.marionette')) :\n  typeof define === 'function' && define.amd ? define(['underscore', 'backbone', 'backbone.marionette'], factory) :\n  factory(global._, global.Backbone, global.Mn)\n}(this, function (_, Backbone, Mn) { 'use strict';\n\n  Mn.SlidingView = Mn.CollectionView.extend({\n    constructor(options = {}) {\n\n      // Throw an error if passed a `collection` option. SlidingView\n      // does not follow the same API as CollectionView, so we want\n      // to catch errors early on\n      if (options.collection) {\n        throw new Error('Do not pass a `collection` option to SlidingView.');\n      }\n\n      // Store the referenceCollection on the SlidingView\n      if (options.referenceCollection) {\n        this.referenceCollection = options.referenceCollection;\n      }\n\n      // Set the collection to be a new empty collection\n      this.collection = new this.collectionClass();\n\n      Mn.CollectionView.prototype.constructor.apply(this, arguments);\n\n      // Get our initial boundaries, and then update the collection\n      this._lowerBound = _.result(this, 'initialLowerBound');\n      this._upperBound = _.result(this, 'initialUpperBound');\n      this._updateCollection();\n\n      // If no onUpdateEvent was defined, then we set one\n      // using the `throttle` method.\n      if (!this.onUpdateEvent) {\n        this.onUpdateEvent = this.throttle(this.throttledUpdateHandler);\n      }\n\n      // Listen to scroll events to continuously update the collection\n      this.registerUpdateEvent();\n    },\n\n    collectionClass: Backbone.Collection,\n\n    // Register the event that calls the onUpdateEvent method. The default\n    // is to listen to the view's own scroll event, but it could just\n    // as easily listen to any event.\n    registerUpdateEvent() {\n\n      // Execute the throttled callback on scroll\n      this.$el.on('scroll', () => {\n        this.onUpdateEvent();\n      });\n    },\n\n    // What we use to throttle the update event callback. Use\n    // requestAnimationFrame in your `onUpdateEvent` callback\n    // for better performance\n    throttle(cb) {\n      return _.throttle(cb, 1000/60);\n    },\n\n    // Called at 60fps whenever the update event occurs\n    throttledUpdateHandler() {\n\n      // Pass along our arguments to the methods that calculate our boundaries\n      var lowerBound = this.getLowerBound();\n      var upperBound = this.getUpperBound(lowerBound);\n\n      // We need to render if either of the boundaries have changed. If this is\n      // the case, and there's already a render in the queue, then we cancel out\n      // that queued render. This prevents users who are scrolling very fast\n      // from getting too many renders at once. It won't render until they've\n      // slowed down a bit.\n      if (lowerBound !== this._lowerBound || upperBound !== this._upperBound) {\n        if (this._deferredUpdateId) {\n          clearTimeout(this._deferredUpdateId);\n        }\n      }\n\n      // If the boundaries are unchanged, then we bail out early\n      if (lowerBound === this._lowerBound && upperBound === this._upperBound) {\n        return;\n      }\n\n      // Update our indices\n      this._lowerBound = lowerBound;\n      this._upperBound = upperBound;\n\n      // Defer an update for 50ms. This prevents many renders when scrolling fast.\n      this._deferredUpdateId = setTimeout(() => {\n        this._updateCollection();\n      }, 50);\n    },\n\n    // The methods that determine our boundaries with each\n    // 'update' (typically the scroll event)\n    getLowerBound() {},\n    getUpperBound() {},\n\n    // Use the boundaries calculated in `onUpdateEvent` to prune\n    // your collection to only the models that you wish to show. Return\n    // an array of models to be set on the collection. The default is\n    // to just return all of the models\n    pruneCollection() {\n      return this.referenceCollection.models;\n    },\n\n    // Update the collection with the results of `pruneCollection`\n    // This leverages two important facts:\n    // 1. Collection#set performs a 'smart' update at the data layer\n    // 2. CollectionView performs a 'smart' update of the view layer\n    //    whenever the data layer changes\n    _updateCollection() {\n      this.collection.set(this.pruneCollection(this._lowerBound, this._upperBound));\n    }\n  });\n\n}));\n"],"sourceRoot":"/source/"}